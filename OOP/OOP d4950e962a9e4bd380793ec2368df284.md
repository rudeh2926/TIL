# OOP

---

## OOP란?

OOP (Object-Oriented Programming)이란 객체 지향적인 프로그래밍. 즉, C언어같은 절차 지향적인 프로그래밍이 아닌 객체의 관점에서 프로그래밍을 한다는 것이다.

OOP는 객체를 기준으로 코드를 나누어 구현한다. 자바의 경우 그 구성 부분 단위가 클래스이다. 자세히 말하자면 클래스는 설계도고 직접일을하는 구현체는 인스턴스다. (객체와 인스턴스는 또 자세히 말하면 다른 의미로 사용되기도 하기 때문에 여기서는 이렇게 말하겠다.)

요약하자면

- OOP는 객체의 관점에서 프로그래밍 하는 것을 의미한다.
- C언어는 절차 지향 프로그래밍인데, 절차 지향 프로그래밍은 프로세스가 함수 단위로 순서대로 진행되는 것을 말한다.
- OOP는 절차지향에 비해서 사람의 사고방식과 더 가깝다.
- OOP는 객체들의 유기적인 관계를 통해서 프로세스가 진행된다.
- 애플리케이션을 구성하는 요소들을 객체로 바라보고, 객체들을 유기적으로 연결하여 프로그래밍 하는 것을 말한다.

자바 프로그래밍하면 객체지향프로그래밍 OOP(Object-Oriented Programming)이라 해도 무방하다.

# OOP의 특징

## 캡슐화 (Encapsulation)

### 캡슐화란

- **하나의 객체에 대해 그 객체가 특정한 목적을 위한 필요한 변수나 메소드를 하나로 묶는 것을 의미한다**.

### 정보은닉

그리고 캡슐화를 하는 중요한 목적은 바로 정보은닉이다. 유저 정보를 가지고 있는 `User`라는 객체에서 유저의 정보가 public으로 선언되어 있다면, 누구든 접근해서 유저 정보를 변경할 수 있다. 그렇기 때문에 private로 해서 데이터를 보호해서 접근을 제한해야한다.

이렇게 보호된 변수는 getter나 setter 등의 메서드를 통해서만 간접적으로 접근이 가능하도록 하는 것이 캡슐화의 중요한 목적이다.(setter도 아무생각 없이 만들면 안된다.)

> 참고로
> 
> 
> 캡슐화와 정보은닉은 동일한 개념이 아니다.
> 
> 캡슐화를 하면 불필요한 정보를 감출 수 있기 때문에, 정보은닉을 할 수 있다는 특징이 있다는 것이다.
> 
> 예를 들어, 리모콘을 사용하는데 리모콘 내부 회로(private으로 정의된 속성)를 알 필요가 있느냐는 것이다.
> 
> 사용자의 입장에서는 리모콘의 조작 기능, 즉 public으로 정의된 속성만 알면 된다는 것이다.
> 

## 추상화 (Abstraction)

추상화는 **목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념이다.**

### 개념설명

세상에 있는 것을 본따 클래스를 만들고 그 클래스의 상태와 행동을 부여한 객체를 만든다.

그러나 세상에 모든 것을 다 클래스에 담고 객체를 만드것은 불가능하다. 그래서 추상적으로 생각해 일단 큰틀의 클래스를 구현하고 거기에 최소 이러한 공통적인 요소나 필수 적인 요소는 들어갔으면 하는 바램에서 만든 것이 `추상클래스`이다.

> 인터페이스와 추상클래스
> 

이 과정에서 공통적인 요소나 특징을 추출하는 과정이 추상화 인것 같다.

예를들어. 벤츠, 아우디, 티코 등등 우리가 생각하는 여러 종류의 자동차가 있다. 이것을 다 클래스화하고 변수와 메서드 등을 개별적으로 만드는 것은 무모한 짓이다. (즉,확장성 때문에 추상화할 필요가 있다.)

따라서 방금 나열한 자동차들의 공통적인 요소나 특징을 추출하는 과정인 추상화를 거쳐 요소를 끄집어 내면 바퀴, 핸들, 차문, 유리창 등 필수적인 부품이 있다.

바퀴는 굴러가고, 핸들은 돌아가고 차문은 열려야한다 공통적인 행동 즉 어떤 차든 필수적으로 필요한 메서드가 추출된다.

이러한 과정이 추상화하는 과정이다. 나중에 이야기하겠지만 이렇게 추상적으로 끄집어 낸 개념들을 큰 틀에서 클래스로 만든것이 바로 `추상클래스`이다.

다시 정리해서 이를 객체와 클래스의 관점에서 보면,

객체들은 실제 그 모습이지만, 클래스는 객체들이 어떤 특징들이 있어야 한다고 정의하는 추상화된 개념이다.

다시 말하자면, **추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법**이라고 할 수 있다.

## 다형성(Polymorphism)

다형성은 상속을 통해 기능을 확장하거나 변경하는 것을 가능하게 해준다. 즉, **다형성은 형태가 같은데 다른 기능을 하는 것을 의미한다(같은 동작이지만 다른 결과물이 나올때 다형이라고 생각하면 된다.).**

이를 통해 코드의 재사용, 코드 길이 감소가 되어 유지보수가 용이하도록 도와준다.

### 개념설명

예를 들면, 고양이 클래스에는 `울음`이라는 속성이 정의되어 있다고 하면,

사자는 고양이 과이기 때문에 사자 클래스는 고양이 클래스를 상속 받는다고 하면, 사자 클래스에도 "울음"이라는 속성이 자동으로 추가된다.

이것을 상속이라고 한다.

그런데 고양이와 사자의 울음소리는 다르다. 같은 "울음" 속성임에도 실제 울음소리는 다르죠.

이런것이 다형성이라고 말할 수 있다.

### Overriding & Overloading

OOP에서 다형성의 개념을 녹여내는 방법은 두가지인데, 바로 **오버라이딩(Overriding)과 오버로딩(Overloading)**이다.

- 오버라이딩부모 클래스에서 상속받은 자식 클래스에서 부모클래스에서 만들어진 메서드를 자식 클래스에서 자신의 입맛대로 다시 재정의해서 사용하는 것을 말한다.
- 오버로딩같은 이름의 메서드를 사용하지만 메서드마다 다른 용도로 사용되며 그 결과물도 다르게 구현할 수 있게 만드는 개념
    - 오버로딩이 가능하려면 메서드끼리 이름은 같지만 매개변수의 갯수나 데이터 타입이 다르면 오버로딩이 적용
    - 메서드 이름이 같아도 문법 에러 ❌

> 오버로딩 오버라이딩 예
> 

```java
// Overriding

public class Employee{

  public String name;
  public int age;

  public void print(){
    System.out.println("사원의 이름 = "+this.name+", 나이 = "+this.age);
  }
}

//Emplyee 상속
public class Manager extends Employee{

  String jobOfManage;

  //overriding  Employee의 pirnt() 메소드 오버라이딩
  public void print(){
    System.out.println("사원의 이름 = "+this.name+", 나이 = "+this.age);
    System.out.println("관리자 "+this.name+"은 "+this.jobOfManage+" 담당입니다.");
  }
}

//Overloading
public class OverloadingTest{

  public void test(){
    System.out.println("사용자 없음");
  }

  public void test(String name){
    System.out.println("사용자 이름 = " +name);
  }

  public void test(String name, int money){
    System.out.println("사용자 이름 = "+name+" , 사용료 = "+money);
  }
}

```

다시 정리하면 같은 행위를 하지만 용도와 목적에 부함하여 다양한 기능 수행과 처리, 결과를 낳을 수 있다.

### 그럼 다형성을 사용하면 좋은 점은 무엇인가?

같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고, 메서드 이름을 낭비하지 않는다는 것이다.

예를 들어, 고양이와 사자의 울음소리를 호출하기 위해서 각 객체에서 roar() 메서드를 호출하면 된다.

roraCat(), roarLion()으로 각각을 정의할 필요가 없다는 것이다.

API가 많아질수록 복잡성은 증가하기 때문에 다형서은 유용하다.

## 상속성, 재사용(Inheritance)

상속은 객체지향의 꽃이라고 할 수 있다.

- 상속이란 기존 상위클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념이다.
- 기존 클래스에 기능을 가져와 재사용할 수 있으면서도 동시에 새롭게 만든 클래스에 새로운 기능을 추가할 수 있게 만들어 준다.

> 자바에선 상속은 단일 상속밖에 지원이 안되며, C++에선 다중상속이 지원된다. 이 때문에 말이 많아 원래 자바 쪽에서는 다중상속이 객체지향적인 관점에서 크게 유효하지 않다고 생각하지만, 다중 상속이 필요할 순 있다고 인정하여 대비책으로 인터페이스를 다중 상속(구현) 할 수 있게 해서 임시적인 다중 상속에 대한 활로는 뚫어 줬다.
> 
> 
> 그러나 **인터페이스의 존재이유가 다중상속을 지원하기 위함이다 라고 생각하면 안된다.**
> 

### 개념정리

실제 세계에서 부모로부터 여러 가지를 상속을 받는데, OOP에서도 가능하다. OOP에서 이를 부모 클래스, 자식클래스라고 표현한다.

예를들어, 고양이 클래스와 강아지 클래스가 있다고 했을때, 고양이와 강아지는 모두 포유류에 해당한다.

포유류는 여러 속성들이 정의되어 있는데 고양이와 강아지는 포유류의 이런 속성들을 갖고 있다.

하지만 아주 많은 속성이 다르기 때문에 좀 더 디테일하게 고양이, 강아지로 종을 나눈것이다.

즉. 포유류라는 클래스는 고양이와 강아지 클래스에 속성들을 물려준다. 이것을 상속이라고 하고, 포유류와 고양이 포유류와 강아지 클래스는 상속 관계에 있다고 한다.

### 상속이 필요한 이유

상속이 필요한 이유는 **코드의 중복을 없애기 위함**이다.

코드의 중복이 많아지면 개발 단계에서도 피곤하지만, 유지 보수에서도 많은 비용이 들게 된다.

그래서 개발을 할때 코드의 중복은 반드시 피해야한다.

OOP에서는 상속을 통해 코드의 중복 문제를 일부 해결할 수 있다.

포유류 클래스에 여러 속성들을 정의해 놓고 포유류에 해당하는 종, 예를 들면 강아지 클래스가 필요한 경우 포유류 클래스와 상속 관계를 맺는다.

상속 관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려 받기 때문에 자식 클래스에서 또 정의할 필요가 없다.

이것이 상속이 필요한 이유이다.

###